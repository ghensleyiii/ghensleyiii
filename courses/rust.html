<!-- COURSE BREAKDOWN
Lessons 1–10: Rust basics (syntax, variables, data types, operators).
Lessons 11–20: Control flow, loops, functions, strings, structs.
Lessons 21–30: Ownership, borrowing, lifetimes, enums, pattern matching.
Lessons 31–40: Modules, error handling, collections, iterators, generics.
Lessons 41–50: Advanced topics (closures, traits, concurrency, unsafe Rust, macros). -->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rust</title>
    <link href="https://fonts.googleapis.com/css2?family=Audiowide&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <header>
        <div class="logo">
            <a href="../index.html">
                <h1>Rust</h1>
            </a>
        </div>
    </header>

    <main>
        <section class="intro">
            <p>Explore 50 progressive Rust lessons to master safe and concurrent programming. Each lesson provides clear explanations and examples to build your coding skills. Start your journey to creating reliable Rust applications today!</p>
        </section>

        <section class="item">
            <!-- Lesson 1 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 1: What is Rust?</summary>
                    <div class="item-content">
                        <h2>Introduction to Rust</h2>
                        <p>Rust is a systems programming language focused on safety, performance, and concurrency. It prevents memory errors through its ownership model, eliminating common bugs like null pointer dereferences. Rust is widely used for web backends, CLI tools, and systems like Firefox.</p>
                        <pre>
fn main() {
    println!("Hello, World!");
}
                        </pre>
                        <div class="example">
                            <p>Output: Hello, World!</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 2 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 2: Variables</summary>
                    <div class="item-content">
                        <h2>Variables in Rust</h2>
                        <p>Variables in Rust are immutable by default, declared with `let`. Use `mut` for mutable variables, and types are often inferred. Rust’s strict variable rules ensure safe data handling.</p>
                        <pre>
fn main() {
    let name = "Alice";
    let mut age = 25;
    age += 1;
    println!("{} is {}", name, age);
}
                        </pre>
                        <div class="example">
                            <p>Output: Alice is 26</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 3 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 3: Data Types</summary>
                    <div class="item-content">
                        <h2>Rust Data Types</h2>
                        <p>Rust has scalar types like `i32`, `f64`, and `bool`, and compound types like tuples and arrays. Types must be known at compile time for safety. Understanding data types is crucial for effective Rust programming.</p>
                        <pre>
fn main() {
    let num: i32 = 42;
    let pi: f64 = 3.14;
    let flag: bool = true;
    println!("{}, {}, {}", num, pi, flag);
}
                        </pre>
                        <div class="example">
                            <p>Output: 42, 3.14, true</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 4 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 4: Arithmetic Operators</summary>
                    <div class="item-content">
                        <h2>Arithmetic Operations</h2>
                        <p>Rust supports arithmetic operators like `+`, `-`, `*`, `/`, and `%`. Operator behavior depends on the type, with no implicit conversions. These operators are fundamental for calculations.</p>
                        <pre>
fn main() {
    let a = 10;
    let b = 3;
    println!("{}, {}", a + b, a % b);
}
                        </pre>
                        <div class="example">
                            <p>Output: 13, 1</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 5 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 5: Comparison Operators</summary>
                    <div class="item-content">
                        <h2>Comparison Operators</h2>
                        <p>Comparison operators like `==`, `!=`, `>`, and `<` return boolean values. They work on compatible types, enforcing type safety. Comparisons are essential for conditional logic.</p>
                        <pre>
fn main() {
    let x = 5;
    let y = 10;
    println!("{}, {}", x < y, x == y);
}
                        </pre>
                        <div class="example">
                            <p>Output: true, false</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 6 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 6: Logical Operators</summary>
                    <div class="item-content">
                        <h2>Logical Operators</h2>
                        <p>Rust’s logical operators `&&`, `||`, and `!` combine or invert boolean expressions. They short-circuit for efficiency, evaluating only as needed. Logical operators are key for complex conditions.</p>
                        <pre>
fn main() {
    let a = true;
    let b = false;
    println!("{}, {}", a && b, a || b);
}
                        </pre>
                        <div class="example">
                            <p>Output: false, true</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 7 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 7: Strings</summary>
                    <div class="item-content">
                        <h2>Working with Strings</h2>
                        <p>Rust has two string types: `&str` for string literals and `String` for owned, mutable strings. `String` supports methods like `push_str()`. Strings are UTF-8 encoded, ensuring broad compatibility.</p>
                        <pre>
fn main() {
    let greeting = "Hello";
    let mut name = String::from("World");
    name.push_str("!");
    println!("{}, {}", greeting, name);
}
                        </pre>
                        <div class="example">
                            <p>Output: Hello, World!</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 8 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 8: String Methods</summary>
                    <div class="item-content">
                        <h2>String Methods</h2>
                        <p>The `String` type offers methods like `trim()`, `to_uppercase()`, and `replace()`. These methods return new values, preserving immutability for `&str`. String methods simplify text manipulation.</p>
                        <pre>
fn main() {
    let text = String::from("  Rust  ");
    let trimmed = text.trim().to_uppercase();
    println!("{}", trimmed);
}
                        </pre>
                        <div class="example">
                            <p>Output: RUST</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 9 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 9: Arrays</summary>
                    <div class="item-content">
                        <h2>Working with Arrays</h2>
                        <p>Arrays in Rust have a fixed length and uniform type, declared with `[T; N]`. They’re stack-allocated and accessed by index. Arrays are useful for small, fixed-size collections.</p>
                        <pre>
fn main() {
    let fruits = ["apple", "banana", "cherry"];
    println!("{}", fruits[1]);
}
                        </pre>
                        <div class="example">
                            <p>Output: banana</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 10 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 10: Slices</summary>
                    <div class="item-content">
                        <h2>Slices</h2>
                        <p>Slices, like `&[T]`, are references to a contiguous portion of an array or vector. They’re flexible and don’t own data. Slices are key for safe data access.</p>
                        <pre>
fn main() {
    let numbers = [1, 2, 3, 4];
    let slice = &numbers[1..3];
    println!("{:?}", slice);
}
                        </pre>
                        <div class="example">
                            <p>Output: [2, 3]</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 11 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 11: If Statements</summary>
                    <div class="item-content">
                        <h2>Conditional Statements</h2>
                        <p>Rust’s `if` statements evaluate boolean conditions, supporting `else if` and `else`. They can return values as expressions. Conditionals are central to program logic.</p>
                        <pre>
fn main() {
    let age = 18;
    let status = if age >= 18 { "Adult" } else { "Minor" };
    println!("{}", status);
}
                        </pre>
                        <div class="example">
                            <p>Output: Adult</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 12 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 12: Match Expressions</summary>
                    <div class="item-content">
                        <h2>Match Expressions</h2>
                        <p>The `match` expression handles multiple conditions, similar to a switch statement. It requires exhaustive patterns, ensuring safety. Match is powerful for control flow.</p>
                        <pre>
fn main() {
    let day = 1;
    let name = match day {
        1 => "Monday",
        _ => "Other",
    };
    println!("{}", name);
}
                        </pre>
                        <div class="example">
                            <p>Output: Monday</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 13 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 13: Loops</summary>
                    <div class="item-content">
                        <h2>Loops</h2>
                        <p>Rust offers `loop` for infinite loops, `while` for condition-based loops, and `for` for iterators. Loops can return values with `break`. Loops are essential for repetition.</p>
                        <pre>
fn main() {
    for i in 0..3 {
        println!("{}", i);
    }
}
                        </pre>
                        <div class="example">
                            <p>Output:<br>0<br>1<br>2</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 14 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 14: While Loops</summary>
                    <div class="item-content">
                        <h2>While Loops</h2>
                        <p>While loops run as long as a condition is true. They’re useful for dynamic iteration counts. Rust ensures loop safety with compile-time checks.</p>
                        <pre>
fn main() {
    let mut count = 1;
    while count <= 3 {
        println!("{}", count);
        count += 1;
    }
}
                        </pre>
                        <div class="example">
                            <p>Output:<br>1<br>2<br>3</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 15 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 15: Break and Continue</summary>
                    <div class="item-content">
                        <h2>Loop Control</h2>
                        <p>The `break` keyword exits a loop, while `continue` skips to the next iteration. Rust supports labeled loops for precise control. These keywords handle special loop cases.</p>
                        <pre>
fn main() {
    for i in 0..5 {
        if i == 3 {
            break;
        }
        println!("{}", i);
    }
}
                        </pre>
                        <div class="example">
                            <p>Output:<br>0<br>1<br>2</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 16 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 16: Functions</summary>
                    <div class="item-content">
                        <h2>Defining Functions</h2>
                        <p>Functions in Rust are declared with `fn`, specifying parameter types and return types. They promote modularity and reusability. Rust’s type system ensures function safety.</p>
                        <pre>
fn greet(name: &str) -> String {
    format!("Hello, {}!", name)
}

fn main() {
    println!("{}", greet("Alice"));
}
                        </pre>
                        <div class="example">
                            <p>Output: Hello, Alice!</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 17 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 17: Structs</summary>
                    <div class="item-content">
                        <h2>Structs</h2>
                        <p>Structs define custom data types with named fields. They can have associated methods using `impl`. Structs are fundamental for structured data in Rust.</p>
                        <pre>
struct Dog {
    name: String,
}

impl Dog {
    fn bark(&self) -> String {
        format!("{} says Woof!", self.name)
    }
}

fn main() {
    let dog = Dog { name: String::from("Buddy") };
    println!("{}", dog.bark());
}
                        </pre>
                        <div class="example">
                            <p>Output: Buddy says Woof!</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 18 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 18: Tuple Structs</summary>
                    <div class="item-content">
                        <h2>Tuple Structs</h2>
                        <p>Tuple structs are structs with unnamed fields, declared like tuples. They’re useful for lightweight data types. Tuple structs combine struct and tuple benefits.</p>
                        <pre>
struct Point(i32, i32);

fn main() {
    let p = Point(3, 4);
    println!("x: {}, y: {}", p.0, p.1);
}
                        </pre>
                        <div class="example">
                            <p>Output: x: 3, y: 4</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 19 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 19: Ownership</summary>
                    <div class="item-content">
                        <h2>Ownership</h2>
                        <p>Rust’s ownership model ensures memory safety without a garbage collector. Each value has a single owner, and it’s freed when the owner goes out of scope. Ownership prevents data races and dangling pointers.</p>
                        <pre>
fn main() {
    let s1 = String::from("hello");
    let s2 = s1; // s1 is moved
    println!("{}", s2);
}
                        </pre>
                        <div class="example">
                            <p>Output: hello</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 20 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 20: Borrowing</summary>
                    <div class="item-content">
                        <h2>Borrowing</h2>
                        <p>Borrowing allows temporary access to data using references (`&`). Rust enforces rules: one mutable borrow or multiple immutable borrows. Borrowing ensures safe data access without ownership transfer.</p>
                        <pre>
fn print_length(s: &String) {
    println!("{}", s.len());
}

fn main() {
    let s = String::from("hello");
    print_length(&s);
    println!("{}", s);
}
                        </pre>
                        <div class="example">
                            <p>Output:<br>5<br>hello</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 21 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 21: Lifetimes</summary>
                    <div class="item-content">
                        <h2>Lifetimes</h2>
                        <p>Lifetimes ensure references are valid for their usage scope, marked with `'a`. They prevent dangling references at compile time. Lifetimes are core to Rust’s safety guarantees.</p>
                        <pre>
fn longest<'a>(s1: &'a str, s2: &'a str) -> &'a str {
    if s1.len() > s2.len() { s1 } else { s2 }
}

fn main() {
    let s1 = "short";
    let s2 = "longer";
    println!("{}", longest(s1, s2));
}
                        </pre>
                        <div class="example">
                            <p>Output: longer</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 22 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 22: Enums</summary>
                    <div class="item-content">
                        <h2>Enums</h2>
                        <p>Enums define a type with a fixed set of variants. They can hold data, making them expressive. Enums are used extensively in Rust for type safety.</p>
                        <pre>
enum Message {
    Text(String),
    Number(i32),
}

fn main() {
    let msg = Message::Text(String::from("hello"));
    match msg {
        Message::Text(s) => println!("{}", s),
        Message::Number(n) => println!("{}", n),
    }
}
                        </pre>
                        <div class="example">
                            <p>Output: hello</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 23 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 23: Pattern Matching</summary>
                    <div class="item-content">
                        <h2>Pattern Matching</h2>
                        <p>Pattern matching with `match` or `if let` deconstructs enums, structs, or tuples. It ensures exhaustive handling of cases. Pattern matching is central to Rust’s expressiveness.</p>
                        <pre>
fn main() {
    let num = Some(42);
    if let Some(n) = num {
        println!("Number: {}", n);
    } else {
        println!("None");
    }
}
                        </pre>
                        <div class="example">
                            <p>Output: Number: 42</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 24 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 24: Option Enum</summary>
                    <div class="item-content">
                        <h2>Option Enum</h2>
                        <p>The `Option<T>` enum represents an optional value: `Some(T)` or `None`. It eliminates null pointer issues, enforcing safe handling. Option is widely used for nullable data.</p>
                        <pre>
fn main() {
    let value: Option<i32> = Some(42);
    match value {
        Some(n) => println!("Value: {}", n),
        None => println!("No value"),
    }
}
                        </pre>
                        <div class="example">
                            <p>Output: Value: 42</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 25 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 25: Result Enum</summary>
                    <div class="item-content">
                        <h2>Result Enum</h2>
                        <p>The `Result<T, E>` enum handles success (`Ok(T)`) or failure (`Err(E)`). It’s used for error handling, replacing exceptions. Result ensures robust error management.</p>
                        <pre>
fn divide(a: i32, b: i32) -> Result<i32, String> {
    if b == 0 {
        Err(String::from("Division by zero"))
    } else {
        Ok(a / b)
    }
}

fn main() {
    match divide(10, 2) {
        Ok(result) => println!("Result: {}", result),
        Err(e) => println!("Error: {}", e),
    }
}
                        </pre>
                        <div class="example">
                            <p>Output: Result: 5</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 26 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 26: Vec</summary>
                    <div class="item-content">
                        <h2>Vec</h2>
                        <p>The `Vec<T>` type is a growable, heap-allocated array. It supports methods like `push()` and `pop()`. Vec is Rust’s primary dynamic collection type.</p>
                        <pre>
fn main() {
    let mut fruits = vec!["apple", "banana"];
    fruits.push("cherry");
    println!("{:?}", fruits);
}
                        </pre>
                        <div class="example">
                            <p>Output: ["apple", "banana", "cherry"]</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 27 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 27: HashMap</summary>
                    <div class="item-content">
                        <h2>HashMap</h2>
                        <p>The `HashMap<K, V>` stores key-value pairs with fast lookups. It’s part of the `std::collections` module. HashMap is ideal for associative data.</p>
                        <pre>
use std::collections::HashMap;

fn main() {
    let mut ages = HashMap::new();
    ages.insert(String::from("Alice"), 25);
    println!("{}", ages["Alice"]);
}
                        </pre>
                        <div class="example">
                            <p>Output: 25</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 28 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 28: Error Handling with ?</summary>
                    <div class="item-content">
                        <h2>Error Handling with ?</h2>
                        <p>The `?` operator propagates errors in functions returning `Result` or `Option`. It simplifies error handling, reducing boilerplate. The `?` operator is concise and safe.</p>
                        <pre>
fn parse_number(s: &str) -> Result<i32, std::num::ParseIntError> {
    let num = s.parse::<i32>()?;
    Ok(num)
}

fn main() {
    match parse_number("42") {
        Ok(n) => println!("Number: {}", n),
        Err(e) => println!("Error: {}", e),
    }
}
                        </pre>
                        <div class="example">
                            <p>Output: Number: 42</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 29 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 29: Modules</summary>
                    <div class="item-content">
                        <h2>Modules</h2>
                        <p>Modules organize code into namespaces using `mod`. The `pub` keyword controls visibility. Modules promote modularity and encapsulation.</p>
                        <pre>
mod utils {
    pub fn greet(name: &str) -> String {
        format!("Hello, {}!", name)
    }
}

fn main() {
    println!("{}", utils::greet("Alice"));
}
                        </pre>
                        <div class="example">
                            <p>Output: Hello, Alice!</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 30 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 30: External Crates</summary>
                    <div class="item-content">
                        <h2>External Crates</h2>
                        <p>Rust uses external crates via `Cargo.toml` for dependencies. The `use` keyword imports crate items. Crates extend Rust’s functionality significantly.</p>
                        <pre>
// Requires `rand = "0.8.5"` in Cargo.toml
use rand::Rng;

fn main() {
    let num = rand::thread_rng().gen_range(1..=10);
    println!("{}", num);
}
                        </pre>
                        <div class="example">
                            <p>Output: (Random number between 1 and 10)</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 31 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 31: File Writing</summary>
                    <div class="item-content">
                        <h2>File Writing</h2>
                        <p>The `std::fs::File` and `std::io` modules handle file output. The `write_all` method writes bytes to a file. File writing is essential for persistent data.</p>
                        <pre>
use std::fs::File;
use std::io::Write;

fn main() -> std::io::Result<()> {
    let mut file = File::create("output.txt")?;
    file.write_all(b"Hello, World!")?;
    println!("File written");
    Ok(())
}
                        </pre>
                        <div class="example">
                            <p>Output: File written</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 32 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 32: File Reading</summary>
                    <div class="item-content">
                        <h2>File Reading</h2>
                        <p>The `std::fs` module provides `read_to_string` for reading files. It returns a `Result` to handle errors. File reading is crucial for data retrieval.</p>
                        <pre>
use std::fs;

fn main() -> std::io::Result<()> {
    let contents = fs::read_to_string("output.txt")?;
    println!("{}", contents);
    Ok(())
}
                        </pre>
                        <div class="example">
                            <p>Output: Hello, World!</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 33 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 33: Generics</summary>
                    <div class="item-content">
                        <h2>Generics</h2>
                        <p>Generics allow functions and types to work with any type, using `<T>`. They ensure type safety at compile time. Generics are widely used in Rust’s standard library.</p>
                        <pre>
fn print_value<T: std::fmt::Display>(value: T) {
    println!("{}", value);
}

fn main() {
    print_value(42);
    print_value("hello");
}
                        </pre>
                        <div class="example">
                            <p>Output:<br>42<br>hello</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 34 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 34: Traits</summary>
                    <div class="item-content">
                        <h2>Traits</h2>
                        <p>Traits define shared behavior for types, like interfaces. They’re implemented with `impl Trait for Type`. Traits enable polymorphism and code reuse.</p>
                        <pre>
trait Speak {
    fn speak(&self) -> String;
}

struct Dog {
    name: String,
}

impl Speak for Dog {
    fn speak(&self) -> String {
        format!("{} says Woof!", self.name)
    }
}

fn main() {
    let dog = Dog { name: String::from("Buddy") };
    println!("{}", dog.speak());
}
                        </pre>
                        <div class="example">
                            <p>Output: Buddy says Woof!</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 35 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 35: Trait Bounds</summary>
                    <div class="item-content">
                        <h2>Trait Bounds</h2>
                        <p>Trait bounds constrain generic types to those implementing specific traits. They’re specified with `T: Trait`. Trait bounds ensure type-safe generic code.</p>
                        <pre>
fn notify<T: std::fmt::Display>(item: T) {
    println!("Item: {}", item);
}

fn main() {
    notify(42);
    notify(String::from("hello"));
}
                        </pre>
                        <div class="example">
                            <p>Output:<br>Item: 42<br>Item: hello</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 36 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 36: Iterators</summary>
                    <div class="item-content">
                        <h2>Iterators</h2>
                        <p>Iterators provide a way to process sequences using methods like `map` and `filter`. They’re lazy, evaluating only when consumed. Iterators are central to Rust’s functional style.</p>
                        <pre>
fn main() {
    let numbers = vec![1, 2, 3];
    let squares: Vec<i32> = numbers.iter().map(|&x| x * x).collect();
    println!("{:?}", squares);
}
                        </pre>
                        <div class="example">
                            <p>Output: [1, 4, 9]</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 37 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 37: Closures</summary>
                    <div class="item-content">
                        <h2>Closures</h2>
                        <p>Closures are anonymous functions that capture their environment, defined with `|args|`. They can borrow or move variables. Closures are flexible for inline logic.</p>
                        <pre>
fn main() {
    let add_one = |x: i32| x + 1;
    let result = add_one(5);
    println!("{}", result);
}
                        </pre>
                        <div class="example">
                            <p>Output: 6</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 38 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 38: Smart Pointers</summary>
                    <div class="item-content">
                        <h2>Smart Pointers</h2>
                        <p>Rust’s smart pointers like `Box<T>` and `Rc<T>` manage memory safely. `Box` provides heap allocation, while `Rc` enables shared ownership. Smart pointers enhance memory management.</p>
                        <pre>
fn main() {
    let boxed = Box::new(42);
    println!("{}", *boxed);
}
                        </pre>
                        <div class="example">
                            <p>Output: 42</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 39 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 39: Reference Counting</summary>
                    <div class="item-content">
                        <h2>Reference Counting</h2>
                        <p>The `Rc<T>` type provides shared ownership with reference counting. Use `Arc<T>` for thread-safe counting. Reference counting is useful for shared data.</p>
                        <pre>
use std::rc::Rc;

fn main() {
    let data = Rc::new(String::from("hello"));
    let data2 = Rc::clone(&data);
    println!("{}", data2);
}
                        </pre>
                        <div class="example">
                            <p>Output: hello</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 40 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 40: Interior Mutability</summary>
                    <div class="item-content">
                        <h2>Interior Mutability</h2>
                        <p>Types like `Cell<T>` and `RefCell<T>` allow mutation through shared references. `RefCell` enforces borrowing rules at runtime. Interior mutability is useful for complex data structures.</p>
                        <pre>
use std::cell::RefCell;

fn main() {
    let data = RefCell::new(42);
    *data.borrow_mut() += 1;
    println!("{}", data.borrow());
}
                        </pre>
                        <div class="example">
                            <p>Output: 43</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 41 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 41: Threads</summary>
                    <div class="item-content">
                        <h2>Threads</h2>
                        <p>Rust’s `std::thread` module spawns threads for concurrent execution. The `spawn` function runs closures in new threads. Threads leverage Rust’s safety for concurrency.</p>
                        <pre>
use std::thread;

fn main() {
    let handle = thread::spawn(|| {
        println!("Running");
    });
    handle.join().unwrap();
}
                        </pre>
                        <div class="example">
                            <p>Output: Running</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 42 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 42: Channels</summary>
                    <div class="item-content">
                        <h2>Channels</h2>
                        <p>Channels, via `std::sync::mpsc`, enable thread communication. The sender (`tx`) and receiver (`rx`) pass messages safely. Channels are key for concurrent data exchange.</p>
                        <pre>
use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();
    thread::spawn(move || {
        tx.send("Hello").unwrap();
    });
    println!("{}", rx.recv().unwrap());
}
                        </pre>
                        <div class="example">
                            <p>Output: Hello</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 43 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 43: Mutex</summary>
                    <div class="item-content">
                        <h2>Mutex</h2>
                        <p>The `Mutex<T>` type ensures thread-safe access to shared data. It uses `lock()` to provide exclusive access. Mutexes prevent data races in concurrent programs.</p>
                        <pre>
use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Mutex::new(0);
    let handle = thread::spawn(move || {
        *counter.lock().unwrap() += 1;
    });
    handle.join().unwrap();
    println!("{}", *counter.lock().unwrap());
}
                        </pre>
                        <div class="example">
                            <p>Output: 1</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 44 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 44: Arc</summary>
                    <div class="item-content">
                        <h2>Arc</h2>
                        <p>The `Arc<T>` type provides thread-safe reference counting. It allows shared ownership across threads. Arc is essential for concurrent shared data.</p>
                        <pre>
use std::sync::Arc;
use std::thread;

fn main() {
    let data = Arc::new(42);
    let data2 = Arc::clone(&data);
    let handle = thread::spawn(move || {
        println!("{}", *data2);
    });
    handle.join().unwrap();
}
                        </pre>
                        <div class="example">
                            <p>Output: 42</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 45 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 45: Derive Macros</summary>
                    <div class="item-content">
                        <h2>Derive Macros</h2>
                        <p>Derive macros automatically implement traits like `Debug` using `#[derive]`. They reduce boilerplate for common functionality. Derive macros enhance code simplicity.</p>
                        <pre>
#[derive(Debug)]
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 3, y: 4 };
    println!("{:?}", p);
}
                        </pre>
                        <div class="example">
                            <p>Output: Point { x: 3, y: 4 }</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 46 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 46: Procedural Macros</summary>
                    <div class="item-content">
                        <h2>Procedural Macros</h2>
                        <p>Procedural macros generate code at compile time, defined in separate crates. They’re more powerful than derive macros, enabling custom syntax. Procedural macros are advanced for framework development.</p>
                        <pre>
// In a separate crate
use proc_macro::TokenStream;

#[proc_macro]
pub fn hello(_input: TokenStream) -> TokenStream {
    "fn hello() { println!(\"Hello!\"); }".parse().unwrap()
}

// main.rs
hello!();

fn main() {
    hello();
}
                        </pre>
                        <div class="example">
                            <p>Output: Hello!</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 47 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 47: Unsafe Rust</summary>
                    <div class="item-content">
                        <h2>Unsafe Rust</h2>
                        <p>Unsafe Rust allows operations like raw pointer dereferencing, bypassing safety checks. It’s used sparingly for low-level code. Unsafe blocks require careful handling to maintain safety.</p>
                        <pre>
fn main() {
    let mut num = 42;
    let ptr = &mut num as *mut i32;
    unsafe {
        *ptr = 43;
    }
    println!("{}", num);
}
                        </pre>
                        <div class="example">
                            <p>Output: 43</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 48 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 48: Async/Await</summary>
                    <div class="item-content">
                        <h2>Async/Await</h2>
                        <p>Rust’s `async` and `.await` enable asynchronous programming for non-blocking tasks. They’re used with runtimes like `tokio`. Async improves performance for I/O-bound applications.</p>
                        <pre>
// Requires `tokio = { version = "1", features = ["full"] }`
use tokio::time::{sleep, Duration};

async fn say_hello() {
    sleep(Duration::from_secs(1)).await;
    println!("Hello!");
}

#[tokio::main]
async fn main() {
    say_hello().await;
}
                        </pre>
                        <div class="example">
                            <p>Output: Hello!</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 49 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 49: Pin and Unpin</summary>
                    <div class="item-content">
                        <h2>Pin and Unpin</h2>
                        <p>The `Pin<T>` type ensures data isn’t moved, critical for async safety. `Unpin` types can be moved freely. Pin is advanced for self-referential structs in async.</p>
                        <pre>
use std::pin::Pin;

fn main() {
    let data = Box::pin(42);
    println!("{}", *data);
}
                        </pre>
                        <div class="example">
                            <p>Output: 42</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 50 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 50: Testing</summary>
                    <div class="item-content">
                        <h2>Testing</h2>
                        <p>Rust’s built-in testing framework uses `#[test]` for unit tests. Tests run with `cargo test`, ensuring code reliability. Testing is integral to Rust’s development workflow.</p>
                        <pre>
#[cfg(test)]
mod tests {
    #[test]
    fn test_add() {
        assert_eq!(2 + 2, 4);
    }
}

fn main() {
    println!("Run with cargo test");
}
                        </pre>
                        <div class="example">
                            <p>Output: (Test passes, no console output)</p>
                        </div>
                    </div>
                </details>
            </div>
        </section>
    </main>

    <footer>
        <p>© 2025 CODEXEDOC. All rights reserved.</p>
    </footer>

</body>
</html>
