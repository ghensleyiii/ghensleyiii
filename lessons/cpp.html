<!-- COURSE BREAKDOWN
Lessons 1–10: C++ basics (syntax, variables, data types, operators).
Lessons 11–20: Control flow, loops, functions, arrays, strings.
Lessons 21–30: Pointers, references, classes, objects, inheritance.
Lessons 31–40: Templates, STL (vectors, maps), exceptions, file I/O.
Lessons 41–50: Advanced topics (smart pointers, lambda expressions, multithreading, move semantics, concepts). -->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>50 C++ Learning Lessons - CODEXEDOC</title>
    <link href="https://fonts.googleapis.com/css2?family=Audiowide&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <header>
        <div class="logo">
            <a href="index.html">
                <h1>CODEXEDOC</h1>
            </a>
        </div>
        <nav>
            <div class="hamburger">
                <span></span>
                <span></span>
                <span></span>
            </div>
            <ul class="nav-menu">
                <li><a href="index.html">Home</a></li>
                <li><a href="bulletins.html">Bulletins</a></li>
                <li><a href="discernment.html">Discernment</a></li>
                <li><a href="guidance.html">Guidance</a></li>
                <li><a href="scriptures.html">Scriptures</a></li>
            </ul>
        </nav>
    </header>

    <main>
        <section class="intro">
            <p class="scripture">"Pay constant attention to yourself and to your teaching. Persevere in these things." —1 Timothy 4:16</p>
            <p>Explore 50 progressive C++ lessons to master systems programming. Each lesson provides clear explanations and examples to build your coding skills. Start your journey to creating high-performance C++ applications today!</p>
        </section>

        <section class="item">
            <!-- Lesson 1 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 1: What is C++?</summary>
                    <div class="item-content">
                        <h2>Introduction to C++</h2>
                        <p>C++ is a powerful, general-purpose programming language with support for object-oriented and generic programming. It’s widely used for system software, games, and high-performance applications due to its speed and control. C++ builds on C, adding features like classes and templates.</p>
                        <pre>
#include <iostream>
using namespace std;

int main() {
    cout << "Hello, World!" << endl;
    return 0;
}
                        </pre>
                        <div class="example">
                            <p>Output: Hello, World!</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 2 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 2: Variables</summary>
                    <div class="item-content">
                        <h2>Variables in C++</h2>
                        <p>Variables in C++ are declared with a specific type, such as int or string, and must be defined before use. They store data in memory, and their type cannot change. Variables are fundamental for manipulating data in programs.</p>
                        <pre>
#include <iostream>
#include <string>
using namespace std;

int main() {
    string name = "Alice";
    int age = 25;
    cout << name << " is " << age << endl;
    return 0;
}
                        </pre>
                        <div class="example">
                            <p>Output: Alice is 25</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 3 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 3: Data Types</summary>
                    <div class="item-content">
                        <h2>C++ Data Types</h2>
                        <p>C++ supports primitive types like int, double, and bool, and composite types like string and arrays. Types determine the size and operations available for data. Understanding data types is essential for efficient programming.</p>
                        <pre>
#include <iostream>
using namespace std;

int main() {
    int num = 42;
    double pi = 3.14;
    bool flag = true;
    cout << num << ", " << pi << ", " << flag << endl;
    return 0;
}
                        </pre>
                        <div class="example">
                            <p>Output: 42, 3.14, 1</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 4 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 4: Arithmetic Operators</summary>
                    <div class="item-content">
                        <h2>Arithmetic Operations</h2>
                        <p>C++ provides operators like +, -, *, /, and % for arithmetic computations. The ++ and -- operators increment or decrement values. These operators are crucial for numerical tasks.</p>
                        <pre>
#include <iostream>
using namespace std;

int main() {
    int a = 10;
    int b = 3;
    cout << a + b << ", " << a % b << endl;
    return 0;
}
                        </pre>
                        <div class="example">
                            <p>Output: 13, 1</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 5 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 5: Comparison Operators</summary>
                    <div class="item-content">
                        <h2>Comparison Operators</h2>
                        <p>Comparison operators like ==, !=, >, and < return boolean values. They are used in conditional statements to evaluate relationships. Comparisons drive decision-making in C++.</p>
                        <pre>
#include <iostream>
using namespace std;

int main() {
    int x = 5;
    int y = 10;
    cout << (x < y) << ", " << (x == y) << endl;
    return 0;
}
                        </pre>
                        <div class="example">
                            <p>Output: 1, 0</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 6 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 6: Logical Operators</summary>
                    <div class="item-content">
                        <h2>Logical Operators</h2>
                        <p>Logical operators &&, ||, and ! combine or invert boolean expressions. They enable complex condition evaluations in control flow. Logical operators are vital for robust logic.</p>
                        <pre>
#include <iostream>
using namespace std;

int main() {
    bool a = true;
    bool b = false;
    cout << (a && b) << ", " << (a || b) << endl;
    return 0;
}
                        </pre>
                        <div class="example">
                            <p>Output: 0, 1</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 7 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 7: Strings</summary>
                    <div class="item-content">
                        <h2>Working with Strings</h2>
                        <p>The std::string class in C++ handles text, supporting concatenation with +. It provides methods like length() and substr(). Strings are essential for text manipulation.</p>
                        <pre>
#include <iostream>
#include <string>
using namespace std;

int main() {
    string greeting = "Hello";
    string name = "World";
    cout << greeting + ", " + name + "!" << endl;
    return 0;
}
                        </pre>
                        <div class="example">
                            <p>Output: Hello, World!</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 8 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 8: String Methods</summary>
                    <div class="item-content">
                        <h2>String Methods</h2>
                        <p>C++ strings offer methods like find(), replace(), and substr() for manipulation. These methods operate on std::string objects efficiently. String methods simplify text processing tasks.</p>
                        <pre>
#include <iostream>
#include <string>
using namespace std;

int main() {
    string text = "  C++  ";
    string trimmed = text.substr(2, 3);
    cout << trimmed << endl;
    return 0;
}
                        </pre>
                        <div class="example">
                            <p>Output: C++</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 9 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 9: Arrays</summary>
                    <div class="item-content">
                        <h2>Working with Arrays</h2>
                        <p>Arrays in C++ are fixed-size collections of the same type, declared with square brackets. They are accessed by index, starting at 0. Arrays are useful for storing sequential data.</p>
                        <pre>
#include <iostream>
using namespace std;

int main() {
    string fruits[] = {"apple", "banana", "cherry"};
    cout << fruits[1] << endl;
    return 0;
}
                        </pre>
                        <div class="example">
                            <p>Output: banana</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 10 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 10: Array Size</summary>
                    <div class="item-content">
                        <h2>Array Size</h2>
                        <p>The sizeof operator can determine an array’s size in bytes, divided by element size to get length. Array size is fixed at compile time. Knowing size prevents out-of-bounds errors.</p>
                        <pre>
#include <iostream>
using namespace std;

int main() {
    int numbers[] = {1, 2, 3, 4};
    cout << sizeof(numbers) / sizeof(numbers[0]) << endl;
    return 0;
}
                        </pre>
                        <div class="example">
                            <p>Output: 4</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 11 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 11: If Statements</summary>
                    <div class="item-content">
                        <h2>Conditional Statements</h2>
                        <p>If statements execute code based on boolean conditions using if, else if, and else. They control program flow dynamically. Conditionals are core to decision-making logic.</p>
                        <pre>
#include <iostream>
using namespace std;

int main() {
    int age = 18;
    if (age >= 18) {
        cout << "Adult" << endl;
    } else {
        cout << "Minor" << endl;
    }
    return 0;
}
                        </pre>
                        <div class="example">
                            <p>Output: Adult</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 12 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 12: Switch Statements</summary>
                    <div class="item-content">
                        <h2>Switch Statements</h2>
                        <p>Switch statements select code blocks based on a variable’s value using case labels. The break keyword prevents fall-through to subsequent cases. Switch is efficient for discrete value checks.</p>
                        <pre>
#include <iostream>
using namespace std;

int main() {
    int day = 1;
    switch (day) {
        case 1:
            cout << "Monday" << endl;
            break;
        default:
            cout << "Other" << endl;
    }
    return 0;
}
                        </pre>
                        <div class="example">
                            <p>Output: Monday</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 13 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 13: For Loops</summary>
                    <div class="item-content">
                        <h2>For Loops</h2>
                        <p>For loops iterate over a range or array with a counter variable. They’re ideal for known iteration counts. For loops are essential for repetitive tasks.</p>
                        <pre>
#include <iostream>
using namespace std;

int main() {
    for (int i = 0; i < 3; i++) {
        cout << i << endl;
    }
    return 0;
}
                        </pre>
                        <div class="example">
                            <p>Output:<br>0<br>1<br>2</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 14 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 14: While Loops</summary>
                    <div class="item-content">
                        <h2>While Loops</h2>
                        <p>While loops execute as long as a condition is true. They’re useful when iteration count is unknown. Use them carefully to avoid infinite loops.</p>
                        <pre>
#include <iostream>
using namespace std;

int main() {
    int count = 1;
    while (count <= 3) {
        cout << count << endl;
        count++;
    }
    return 0;
}
                        </pre>
                        <div class="example">
                            <p>Output:<br>1<br>2<br>3</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 15 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 15: Break and Continue</summary>
                    <div class="item-content">
                        <h2>Loop Control</h2>
                        <p>The break statement exits a loop, while continue skips to the next iteration. They provide precise control over loop execution. These statements handle special cases efficiently.</p>
                        <pre>
#include <iostream>
using namespace std;

int main() {
    for (int i = 0; i < 5; i++) {
        if (i == 3) break;
        cout << i << endl;
    }
    return 0;
}
                        </pre>
                        <div class="example">
                            <p>Output:<br>0<br>1<br>2</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 16 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 16: Functions</summary>
                    <div class="item-content">
                        <h2>Defining Functions</h2>
                        <p>Functions in C++ encapsulate reusable code, declared with a return type and parameters. They promote modularity and code organization. Functions are defined outside main() typically.</p>
                        <pre>
#include <iostream>
using namespace std;

string greet(string name) {
    return "Hello, " + name + "!";
}

int main() {
    cout << greet("Alice") << endl;
    return 0;
}
                        </pre>
                        <div class="example">
                            <p>Output: Hello, Alice!</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 17 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 17: Function Overloading</summary>
                    <div class="item-content">
                        <h2>Function Overloading</h2>
                        <p>Function overloading allows multiple functions with the same name but different parameters. The compiler selects the correct function based on arguments. Overloading enhances code flexibility.</p>
                        <pre>
#include <iostream>
using namespace std;

int add(int a, int b) {
    return a + b;
}
double add(double a, double b) {
    return a + b;
}

int main() {
    cout << add(2, 3) << ", " << add(2.5, 3.5) << endl;
    return 0;
}
                        </pre>
                        <div class="example">
                            <p>Output: 5, 6</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 18 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 18: Pointers</summary>
                    <div class="item-content">
                        <h2>Pointers</h2>
                        <p>Pointers store memory addresses, declared with the * operator. The & operator gets a variable’s address. Pointers are fundamental for dynamic memory and low-level control.</p>
                        <pre>
#include <iostream>
using namespace std;

int main() {
    int x = 10;
    int* ptr = &x;
    cout << *ptr << endl;
    return 0;
}
                        </pre>
                        <div class="example">
                            <p>Output: 10</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 19 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 19: References</summary>
                    <div class="item-content">
                        <h2>References</h2>
                        <p>References, declared with &, are aliases for existing variables. They provide a safer alternative to pointers for parameter passing. References simplify code and improve readability.</p>
                        <pre>
#include <iostream>
using namespace std;

void increment(int& ref) {
    ref++;
}

int main() {
    int x = 5;
    increment(x);
    cout << x << endl;
    return 0;
}
                        </pre>
                        <div class="example">
                            <p>Output: 6</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 20 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 20: Classes</summary>
                    <div class="item-content">
                        <h2>Classes and Objects</h2>
                        <p>Classes define blueprints for objects, encapsulating data and methods. Objects are instances created with the new keyword or directly. Classes are central to C++’s object-oriented programming.</p>
                        <pre>
#include <iostream>
#include <string>
using namespace std;

class Dog {
public:
    string name;
    Dog(string n) : name(n) {}
    string bark() { return name + " says Woof!"; }
};

int main() {
    Dog dog("Buddy");
    cout << dog.bark() << endl;
    return 0;
}
                        </pre>
                        <div class="example">
                            <p>Output: Buddy says Woof!</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 21 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 21: Constructors</summary>
                    <div class="item-content">
                        <h2>Constructors</h2>
                        <p>Constructors initialize objects, sharing the class name and having no return type. They can be overloaded for flexibility. Constructors ensure proper object setup.</p>
                        <pre>
#include <iostream>
#include <string>
using namespace std;

class Person {
public:
    string name;
    int age;
    Person(string n, int a) : name(n), age(a) {}
};

int main() {
    Person p("Alice", 25);
    cout << p.name << ", " << p.age << endl;
    return 0;
}
                        </pre>
                        <div class="example">
                            <p>Output: Alice, 25</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 22 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 22: Inheritance</summary>
                    <div class="item-content">
                        <h2>Inheritance</h2>
                        <p>Inheritance allows a class to inherit members from a base class using :. It supports code reuse and polymorphism. Access specifiers control inherited member visibility.</p>
                        <pre>
#include <iostream>
#include <string>
using namespace std;

class Animal {
public:
    string name;
    Animal(string n) : name(n) {}
};

class Dog : public Animal {
public:
    Dog(string n) : Animal(n) {}
    string bark() { return name + " barks!"; }
};

int main() {
    Dog dog("Max");
    cout << dog.bark() << endl;
    return 0;
}
                        </pre>
                        <div class="example">
                            <p>Output: Max barks!</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 23 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 23: Method Overriding</summary>
                    <div class="item-content">
                        <h2>Method Overriding</h2>
                        <p>Method overriding redefines a base class method in a derived class using virtual. The override keyword ensures correctness. Overriding enables polymorphic behavior.</p>
                        <pre>
#include <iostream>
using namespace std;

class Animal {
public:
    virtual string sound() { return "Some sound"; }
};

class Dog : public Animal {
public:
    string sound() override { return "Woof!"; }
};

int main() {
    Dog dog;
    cout << dog.sound() << endl;
    return 0;
}
                        </pre>
                        <div class="example">
                            <p>Output: Woof!</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 24 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 24: Abstract Classes</summary>
                    <div class="item-content">
                        <h2>Abstract Classes</h2>
                        <p>Abstract classes, with pure virtual functions (=0), cannot be instantiated. They define interfaces for derived classes. Abstract classes ensure consistent behavior across subclasses.</p>
                        <pre>
#include <iostream>
using namespace std;

class Animal {
public:
    virtual string sound() = 0;
};

class Dog : public Animal {
public:
    string sound() override { return "Woof!"; }
};

int main() {
    Dog dog;
    cout << dog.sound() << endl;
    return 0;
}
                        </pre>
                        <div class="example">
                            <p>Output: Woof!</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 25 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 25: Encapsulation</summary>
                    <div class="item-content">
                        <h2>Encapsulation</h2>
                        <p>Encapsulation hides data with private members, exposing only public methods. It protects object state and promotes modularity. Encapsulation is a core OOP principle.</p>
                        <pre>
#include <iostream>
#include <string>
using namespace std;

class Person {
private:
    string name;
public:
    void setName(string n) { name = n; }
    string getName() { return name; }
};

int main() {
    Person p;
    p.setName("Bob");
    cout << p.getName() << endl;
    return 0;
}
                        </pre>
                        <div class="example">
                            <p>Output: Bob</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 26 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 26: Vector</summary>
                    <div class="item-content">
                        <h2>STL Vector</h2>
                        <p>The std::vector, part of the Standard Template Library (STL), is a dynamic array. It supports methods like push_back() and size(). Vectors are ideal for resizable collections.</p>
                        <pre>
#include <iostream>
#include <vector>
using namespace std;

int main() {
    vector<string> fruits;
    fruits.push_back("apple");
    fruits.push_back("banana");
    cout << fruits[1] << endl;
    return 0;
}
                        </pre>
                        <div class="example">
                            <p>Output: banana</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 27 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 27: Map</summary>
                    <div class="item-content">
                        <h2>STL Map</h2>
                        <p>The std::map stores key-value pairs, sorted by keys. It provides fast lookups with operator[]. Maps are useful for associative data storage.</p>
                        <pre>
#include <iostream>
#include <map>
#include <string>
using namespace std;

int main() {
    map<string, int> ages;
    ages["Alice"] = 25;
    cout << ages["Alice"] << endl;
    return 0;
}
                        </pre>
                        <div class="example">
                            <p>Output: 25</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 28 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 28: Exception Handling</summary>
                    <div class="item-content">
                        <h2>Exception Handling</h2>
                        <p>Try-catch blocks handle exceptions, preventing program crashes. The throw keyword triggers errors. Exception handling ensures robust applications.</p>
                        <pre>
#include <iostream>
using namespace std;

int main() {
    try {
        throw runtime_error("Error occurred");
    } catch (const runtime_error& e) {
        cout << e.what() << endl;
    }
    return 0;
}
                        </pre>
                        <div class="example">
                            <p>Output: Error occurred</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 29 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 29: Templates</summary>
                    <div class="item-content">
                        <h2>Templates</h2>
                        <p>Templates enable generic programming with type parameters. They allow functions or classes to work with any type. Templates are key for reusable code.</p>
                        <pre>
#include <iostream>
using namespace std;

template <typename T>
T add(T a, T b) {
    return a + b;
}

int main() {
    cout << add(2, 3) << ", " << add(2.5, 3.5) << endl;
    return 0;
}
                        </pre>
                        <div class="example">
                            <p>Output: 5, 6</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 30 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 30: Class Templates</summary>
                    <div class="item-content">
                        <h2>Class Templates</h2>
                        <p>Class templates define generic classes with type parameters. They’re instantiated with specific types at compile time. Class templates are used in STL containers.</p>
                        <pre>
#include <iostream>
using namespace std;

template <typename T>
class Box {
public:
    T value;
    Box(T v) : value(v) {}
};

int main() {
    Box<int> box(42);
    cout << box.value << endl;
    return 0;
}
                        </pre>
                        <div class="example">
                            <p>Output: 42</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 31 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 31: File Writing</summary>
                    <div class="item-content">
                        <h2>File Writing</h2>
                        <p>The std::ofstream class writes to files using the << operator. It’s part of the <fstream> library. File writing is essential for persistent data storage.</p>
                        <pre>
#include <iostream>
#include <fstream>
using namespace std;

int main() {
    ofstream file("output.txt");
    if (file.is_open()) {
        file << "Hello, World!";
        file.close();
        cout << "File written" << endl;
    }
    return 0;
}
                        </pre>
                        <div class="example">
                            <p>Output: File written</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 32 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 32: File Reading</summary>
                    <div class="item-content">
                        <h2>File Reading</h2>
                        <p>The std::ifstream class reads from files using the >> operator or getline(). It supports text file processing. File reading is crucial for data retrieval.</p>
                        <pre>
#include <iostream>
#include <fstream>
#include <string>
using namespace std;

int main() {
    ifstream file("output.txt");
    string line;
    if (file.is_open()) {
        getline(file, line);
        cout << line << endl;
        file.close();
    }
    return 0;
}
                        </pre>
                        <div class="example">
                            <p>Output: Hello, World!</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 33 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 33: Smart Pointers</summary>
                    <div class="item-content">
                        <h2>Smart Pointers</h2>
                        <p>Smart pointers like std::unique_ptr manage memory automatically. They prevent leaks by deleting objects when out of scope. Smart pointers are essential for modern C++.</p>
                        <pre>
#include <iostream>
#include <memory>
using namespace std;

int main() {
    unique_ptr<int> ptr = make_unique<int>(42);
    cout << *ptr << endl;
    return 0;
}
                        </pre>
                        <div class="example">
                            <p>Output: 42</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 34 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 34: Shared Pointers</summary>
                    <div class="item-content">
                        <h2>Shared Pointers</h2>
                        <p>The std::shared_ptr allows multiple pointers to share ownership of an object. It uses reference counting to manage deletion. Shared pointers are useful for shared resources.</p>
                        <pre>
#include <iostream>
#include <memory>
using namespace std;

int main() {
    shared_ptr<int> ptr1 = make_shared<int>(42);
    shared_ptr<int> ptr2 = ptr1;
    cout << *ptr1 << endl;
    return 0;
}
                        </pre>
                        <div class="example">
                            <p>Output: 42</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 35 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 35: Lambda Expressions</summary>
                    <div class="item-content">
                        <h2>Lambda Expressions</h2>
                        <p>Lambda expressions, introduced in C++11, define anonymous functions with []. They’re used for short, inline functions, often with STL algorithms. Lambdas enhance functional programming.</p>
                        <pre>
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
    vector<int> nums = {1, 2, 3};
    for_each(nums.begin(), nums.end(), [](int n) {
        cout << n * n << " ";
    });
    cout << endl;
    return 0;
}
                        </pre>
                        <div class="example">
                            <p>Output: 1 4 9</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 36 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 36: Auto Keyword</summary>
                    <div class="item-content">
                        <h2>Auto Keyword</h2>
                        <p>The auto keyword, introduced in C++11, infers variable types at compile time. It simplifies code for complex types like iterators. Auto improves code readability and maintenance.</p>
                        <pre>
#include <iostream>
#include <vector>
using namespace std;

int main() {
    vector<int> nums = {1, 2, 3};
    for (auto n : nums) {
        cout << n << " ";
    }
    cout << endl;
    return 0;
}
                        </pre>
                        <div class="example">
                            <p>Output: 1 2 3</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 37 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 37: Range-Based For Loop</summary>
                    <div class="item-content">
                        <h2>Range-Based For Loop</h2>
                        <p>Range-based for loops, introduced in C++11, iterate over containers like arrays or vectors. They simplify iteration syntax. These loops are concise and readable.</p>
                        <pre>
#include <iostream>
#include <vector>
using namespace std;

int main() {
    vector<string> fruits = {"apple", "banana"};
    for (const auto& fruit : fruits) {
        cout << fruit << " ";
    }
    cout << endl;
    return 0;
}
                        </pre>
                        <div class="example">
                            <p>Output: apple banana</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 38 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 38: Multithreading</summary>
                    <div class="item-content">
                        <h2>Multithreading</h2>
                        <p>The std::thread class, introduced in C++11, enables concurrent execution. Threads run functions independently, improving performance. Multithreading is key for parallel tasks.</p>
                        <pre>
#include <iostream>
#include <thread>
using namespace std;

void task() {
    cout << "Running" << endl;
}

int main() {
    thread t(task);
    t.join();
    return 0;
}
                        </pre>
                        <div class="example">
                            <p>Output: Running</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 39 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 39: Mutex</summary>
                    <div class="item-content">
                        <h2>Mutex</h2>
                        <p>The std::mutex class ensures thread-safe access to shared resources. It prevents race conditions using lock() and unlock(). Mutexes are critical for concurrent programming.</p>
                        <pre>
#include <iostream>
#include <thread>
#include <mutex>
using namespace std;

mutex mtx;
int count = 0;

void increment() {
    mtx.lock();
    count++;
    mtx.unlock();
}

int main() {
    thread t1(increment);
    thread t2(increment);
    t1.join();
    t2.join();
    cout << count << endl;
    return 0;
}
                        </pre>
                        <div class="example">
                            <p>Output: 2</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 40 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 40: Move Semantics</summary>
                    <div class="item-content">
                        <h2>Move Semantics</h2>
                        <p>Move semantics, introduced in C++11, optimize resource transfer with rvalue references (&&). They reduce copying for temporary objects. Move semantics improve performance.</p>
                        <pre>
#include <iostream>
#include <string>
using namespace std;

class Resource {
public:
    string data;
    Resource(string d) : data(d) {}
    Resource(Resource&& other) noexcept : data(move(other.data)) {}
};

int main() {
    Resource r1("test");
    Resource r2 = move(r1);
    cout << r2.data << endl;
    return 0;
}
                        </pre>
                        <div class="example">
                            <p>Output: test</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 41 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 41: Regular Expressions</summary>
                    <div class="item-content">
                        <h2>Regular Expressions</h2>
                        <p>The <regex> library provides std::regex for pattern matching. Methods like regex_match() validate strings. Regex is powerful for text processing.</p>
                        <pre>
#include <iostream>
#include <regex>
using namespace std;

int main() {
    regex r("\\d+");
    if (regex_match("123", r)) {
        cout << "Valid number" << endl;
    }
    return 0;
}
                        </pre>
                        <div class="example">
                            <p>Output: Valid number</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 42 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 42: STL Algorithms</summary>
                    <div class="item-content">
                        <h2>STL Algorithms</h2>
                        <p>The <algorithm> library provides functions like sort(), find(), and transform(). They operate on containers efficiently. STL algorithms simplify complex operations.</p>
                        <pre>
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
    vector<int> nums = {3, 1, 2};
    sort(nums.begin(), nums.end());
    for (int n : nums) cout << n << " ";
    cout << endl;
    return 0;
}
                        </pre>
                        <div class="example">
                            <p>Output: 1 2 3</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 43 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 43: Constexpr</summary>
                    <div class="item-content">
                        <h2>Constexpr</h2>
                        <p>The constexpr keyword, introduced in C++11, enables compile-time computations. It ensures functions or variables are evaluated at compile time. Constexpr improves performance and safety.</p>
                        <pre>
#include <iostream>
using namespace std;

constexpr int square(int x) {
    return x * x;
}

int main() {
    constexpr int result = square(5);
    cout << result << endl;
    return 0;
}
                        </pre>
                        <div class="example">
                            <p>Output: 25</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 44 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 44: Variadic Templates</summary>
                    <div class="item-content">
                        <h2>Variadic Templates</h2>
                        <p>Variadic templates, introduced in C++11, handle variable numbers of arguments. They use parameter packs and recursion. Variadic templates enable flexible generic code.</p>
                        <pre>
#include <iostream>
using namespace std;

template <typename... Args>
int sum(Args... args) {
    return (args + ...);
}

int main() {
    cout << sum(1, 2, 3) << endl;
    return 0;
}
                        </pre>
                        <div class="example">
                            <p>Output: 6</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 45 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 45: Type Traits</summary>
                    <div class="item-content">
                        <h2>Type Traits</h2>
                        <p>The <type_traits> library provides compile-time type information, like is_integral. They enable conditional compilation in templates. Type traits enhance generic programming.</p>
                        <pre>
#include <iostream>
#include <type_traits>
using namespace std;

template <typename T>
void checkType(T) {
    if (is_integral<T>::value) {
        cout << "Integral type" << endl;
    }
}

int main() {
    checkType(42);
    return 0;
}
                        </pre>
                        <div class="example">
                            <p>Output: Integral type</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 46 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 46: Concepts</summary>
                    <div class="item-content">
                        <h2>Concepts</h2>
                        <p>Concepts, introduced in C++20, constrain template types with requirements. They improve error messages and code clarity. Concepts enhance generic programming robustness.</p>
                        <pre>
#include <iostream>
#include <concepts>
using namespace std;

template <typename T>
requires integral<T>
T add(T a, T b) {
    return a + b;
}

int main() {
    cout << add(2, 3) << endl;
    return 0;
}
                        </pre>
                        <div class="example">
                            <p>Output: 5</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 47 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 47: Modules</summary>
                    <div class="item-content">
                        <h2>Modules</h2>
                        <p>Modules, introduced in C++20, replace headers for better encapsulation. They use export and import keywords. Modules improve compilation speed and modularity.</p>
                        <pre>
// math.cppm
export module math;
export int add(int a, int b) {
    return a + b;
}

// main.cpp
#include <iostream>
import math;
using namespace std;

int main() {
    cout << add(2, 3) << endl;
    return 0;
}
                        </pre>
                        <div class="example">
                            <p>Output: 5</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 48 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 48: Coroutines</summary>
                    <div class="item-content">
                        <h2>Coroutines</h2>
                        <p>Coroutines, introduced in C++20, enable asynchronous or lazy evaluation. They use co_yield and co_return. Coroutines are advanced for generators and async tasks.</p>
                        <pre>
#include <iostream>
#include <coroutine>
using namespace std;

struct Generator {
    struct promise_type {
        int value;
        auto get_return_object() { return Generator{*this}; }
        auto initial_suspend() { return suspend_always{}; }
        auto final_suspend() noexcept { return suspend_always{}; }
        void unhandled_exception() {}
        auto yield_value(int v) { value = v; return suspend_always{}; }
    };
    struct Handle { using promise_type = promise_type; };
    coroutine_handle<promise_type> coro;
    Generator(promise_type& p) : coro(coroutine_handle<promise_type>::from_promise(p)) {}
    ~Generator() { if (coro) coro.destroy(); }
};

Generator generate() {
    co_yield 1;
}

int main() {
    auto g = generate();
    cout << g.coro.promise().value << endl;
    return 0;
}
                        </pre>
                        <div class="example">
                            <p>Output: 1</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 49 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 49: Ranges</summary>
                    <div class="item-content">
                        <h2>Ranges</h2>
                        <p>The <ranges> library, introduced in C++20, provides composable views for containers. It simplifies operations like filtering and transforming. Ranges enhance STL usability.</p>
                        <pre>
#include <iostream>
#include <vector>
#include <ranges>
using namespace std;

int main() {
    vector<int> nums = {1, 2, 3, 4};
    auto even = nums | views::filter([](int n) { return n % 2 == 0; });
    for (int n : even) cout << n << " ";
    cout << endl;
    return 0;
}
                        </pre>
                        <div class="example">
                            <p>Output: 2 4</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 50 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 50: Structured Bindings</summary>
                    <div class="item-content">
                        <h2>Structured Bindings</h2>
                        <p>Structured bindings, introduced in C++17, unpack tuples or structs into variables. They simplify code for multiple return values. Structured bindings improve readability.</p>
                        <pre>
#include <iostream>
#include <tuple>
using namespace std;

tuple<int, string> getData() {
    return {42, "Alice"};
}

int main() {
    auto [num, name] = getData();
    cout << num << ", " << name << endl;
    return 0;
}
                        </pre>
                        <div class="example">
                            <p>Output: 42, Alice</p>
                        </div>
                    </div>
                </details>
            </div>
        </section>
    </main>

    <footer>
        <p>© 2025 CODEXEDOC. All rights reserved.</p>
    </footer>

    <script href="script.js">
    </script>
</body>
</html>
