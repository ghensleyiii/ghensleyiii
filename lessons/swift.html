<!-- COURSE BREAKDOWN
Lessons 1–10: Swift basics (syntax, variables, constants, data types, operators).
Lessons 11–20: Control flow, functions, optionals, arrays, dictionaries, strings.
Lessons 21–30: Structs, classes, protocols, error handling, closures.
Lessons 31–40: Generics, properties, access control, file handling, JSON.
Lessons 41–50: Advanced topics (async/await, actors, SwiftUI, Core Data, networking).-->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>50 Swift Learning Lessons - CODEXEDOC</title>
    <link href="https://fonts.googleapis.com/css2?family=Audiowide&display=swap" rel="stylesheet">
    <style>
        :root {
            --dark-blue: #4169e1;
            --light-blue: #41E169;
            --white: #f0f2f0;
            --black: #333333;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: Arial, sans-serif;
            background-color: var(--white);
            color: var(--black);
            line-height: 1.6;
        }

        header {
            background: linear-gradient(135deg, var(--dark-blue), var(--light-blue));
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            position: sticky;
            top: 0;
            z-index: 100;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logo h1 {
            font-family: 'Audiowide', sans-serif;
            color: #fff;
            font-size: 36px;
            margin: 0;
        }

        .logo a {
            text-decoration: none;
            color: #fff;
        }

        nav {
            display: flex;
            align-items: center;
        }

        .hamburger {
            display: none;
            flex-direction: column;
            cursor: pointer;
        }

        .hamburger span {
            background: #fff;
            height: 3px;
            width: 25px;
            margin: 2px 0;
            transition: all 0.3s ease;
        }

        .hamburger.active span:nth-child(1) {
            transform: rotate(45deg) translate(5px, 5px);
        }

        .hamburger.active span:nth-child(2) {
            opacity: 0;
        }

        .hamburger.active span:nth-child(3) {
            transform: rotate(-45deg) translate(7px, -7px);
        }

        .nav-menu {
            display: flex;
            list-style: none;
        }

        .nav-menu li {
            margin-left: 20px;
        }

        .nav-menu a {
            color: #fff;
            text-decoration: none;
            font-family: 'Audiowide', sans-serif;
            font-size: 18px;
        }

        .nav-menu a:hover {
            color: #e0e0e0;
        }

        @media (max-width: 768px) {
            .hamburger {
                display: flex;
            }

            .nav-menu {
                display: none;
                flex-direction: column;
                position: absolute;
                top: 70px;
                right: 0;
                background: linear-gradient(135deg, var(--dark-blue), var(--light-blue));
                width: 200px;
                padding: 20px;
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            }

            .nav-menu.active {
                display: flex;
            }

            .nav-menu li {
                margin: 10px 0;
            }
        }

        main {
            max-width: 100%;
            margin: 0;
            padding: 0;
        }

        .intro {
            background: linear-gradient(135deg, #A3BFFA, #c8e6c9);
            padding: 20px;
            margin-bottom: 30px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
            text-align: center;
        }

        .scripture {
            background: linear-gradient(135deg, var(--dark-blue), var(--light-blue));
            padding: 15px;
            margin: 10px auto;
            border-radius: 8px;
            font-style: italic;
            color: #fff;
            max-width: 800px;
            text-align: center;
        }

        .item {
            margin-bottom: 20px;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
        }

        .item-button {
            display: block;
            width: 100%;
            padding: 15px;
            font-family: 'Audiowide', sans-serif;
            background: linear-gradient(135deg, var(--dark-blue), var(--light-blue));
            border: none;
            color: #fff;
            text-align: center;
            cursor: pointer;
            border-radius: 5px;
            transition: background 0.3s;
        }

        .item-button:hover {
            background: linear-gradient(135deg, #2F4B9F, #2F9F4B);
        }

        .item-content {
            padding: 20px;
            background: #e8f5e9;
            border-radius: 0 0 5px 5px;
            text-align: left;
        }

        .item-content h2 {
            font-family: 'Audiowide', sans-serif;
            color: var(--dark-blue);
            margin-bottom: 10px;
        }

        .item-content pre {
            background: #f4f4f4;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
        }

        .example {
            margin-top: 10px;
            padding: 10px;
            border: 1px solid var(--dark-blue);
            border-radius: 5px;
        }

        footer {
            background: linear-gradient(135deg, var(--dark-blue), var(--light-blue));
            text-align: center;
            padding: 20px;
            color: #fff;
            box-shadow: 0 -4px 6px rgba(0, 0, 0, 0.1);
            width: 100%;
        }
    </style>
</head>
<body>
    <header>
        <div class="logo">
            <a href="index.html">
                <h1>CODEXEDOC</h1>
            </a>
        </div>
        <nav>
            <div class="hamburger">
                <span></span>
                <span></span>
                <span></span>
            </div>
            <ul class="nav-menu">
                <li><a href="index.html">Home</a></li>
                <li><a href="bulletins.html">Bulletins</a></li>
                <li><a href="discernment.html">Discernment</a></li>
                <li><a href="guidance.html">Guidance</a></li>
                <li><a href="scriptures.html">Scriptures</a></li>
            </ul>
        </nav>
    </header>

    <main>
        <section class="intro">
            <p class="scripture">"Pay constant attention to yourself and to your teaching. Persevere in these things." —1 Timothy 4:16</p>
            <p>Explore 50 progressive Swift lessons to master safe and performant iOS/macOS development. Each lesson provides clear explanations and examples to build your coding skills. Start your journey to creating powerful Swift applications today!</p>
        </section>

        <section class="item">
            <!-- Lesson 1 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 1: What is Swift?</summary>
                    <div class="item-content">
                        <h2>Introduction to Swift</h2>
                        <p>Swift is a powerful, open-source programming language created by Apple for iOS, macOS, and more. It emphasizes safety, performance, and modern syntax, used in apps like Uber. Swift’s type safety and clarity make it ideal for mobile and server-side development.</p>
                        <pre>
print("Hello, World!")
                        </pre>
                        <div class="example">
                            <p>Output: Hello, World!</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 2 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 2: Variables and Constants</summary>
                    <div class="item-content">
                        <h2>Variables and Constants</h2>
                        <p>Swift uses `var` for variables and `let` for constants, with strong type inference. Constants cannot be reassigned, ensuring safety. Variables and constants are foundational for storing data in Swift.</p>
                        <pre>
var name = "Alice"
let age = 25
print("\(name) is \(age)")
                        </pre>
                        <div class="example">
                            <p>Output: Alice is 25</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 3 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 3: Data Types</summary>
                    <div class="item-content">
                        <h2>Swift Data Types</h2>
                        <p>Swift supports types like `Int`, `Double`, `String`, `Bool`, arrays, and dictionaries. Type inference reduces boilerplate, but explicit types can be specified. Understanding data types is key to Swift’s type-safe programming.</p>
                        <pre>
let num: Int = 42
let pi: Double = 3.14
let flag = true
print(num, pi, flag)
                        </pre>
                        <div class="example">
                            <p>Output: 42 3.14 true</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 4 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 4: Arithmetic Operators</summary>
                    <div class="item-content">
                        <h2>Arithmetic Operations</h2>
                        <p>Swift provides arithmetic operators like `+`, `-`, `*`, `/`, and `%` for numbers. It enforces type safety, preventing mismatched types. These operators are essential for calculations.</p>
                        <pre>
let a = 10
let b = 3
print(a + b, a % b)
                        </pre>
                        <div class="example">
                            <p>Output: 13 1</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 5 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 5: Comparison Operators</summary>
                    <div class="item-content">
                        <h2>Comparison Operators</h2>
                        <p>Swift’s comparison operators (`==`, `!=`, `>`, `<`, `>=`, `<=`) return `Bool` values. They work on comparable types like numbers and strings. Comparisons drive conditional logic in Swift.</p>
                        <pre>
let x = 5
let y = 10
print(x < y, x == y)
                        </pre>
                        <div class="example">
                            <p>Output: true false</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 6 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 6: Logical Operators</summary>
                    <div class="item-content">
                        <h2>Logical Operators</h2>
                        <p>Swift’s logical operators `&&`, `||`, and `!` combine or invert boolean expressions. They short-circuit for efficiency, evaluating only as needed. Logical operators are crucial for complex conditions.</p>
                        <pre>
let a = true
let b = false
print(a && b, a || b)
                        </pre>
                        <div class="example">
                            <p>Output: false true</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 7 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 7: Strings</summary>
                    <div class="item-content">
                        <h2>Working with Strings</h2>
                        <p>Strings in Swift are Unicode-compliant, created with quotes and supporting interpolation with `\()`. They are value types, ensuring safety. Strings are central to text handling in Swift.</p>
                        <pre>
let greeting = "Hello"
let name = "World"
print("\(greeting), \(name)!")
                        </pre>
                        <div class="example">
                            <p>Output: Hello, World!</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 8 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 8: String Methods</summary>
                    <div class="item-content">
                        <h2>String Methods</h2>
                        <p>Swift’s `String` type provides methods like `uppercased()`, `hasPrefix()`, and `replacingOccurrences()`. These methods are safe and Unicode-aware. String methods enable efficient text manipulation.</p>
                        <pre>
let text = "  swift  "
print(text.trimmingCharacters(in: .whitespaces).uppercased())
                        </pre>
                        <div class="example">
                            <p>Output: SWIFT</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 9 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 9: Arrays</summary>
                    <div class="item-content">
                        <h2>Working with Arrays</h2>
                        <p>Arrays in Swift are type-safe, ordered collections, created with `[]` or `Array<Type>`. They support methods like `append()` and `remove()`. Arrays are versatile for managing sequences.</p>
                        <pre>
var fruits = ["apple", "banana", "cherry"]
print(fruits[1])
                        </pre>
                        <div class="example">
                            <p>Output: banana</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 10 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 10: Dictionaries</summary>
                    <div class="item-content">
                        <h2>Dictionaries</h2>
                        <p>Dictionaries in Swift are key-value stores, created with `[:]` or `Dictionary<Key, Value>`. They require hashable keys and support optional lookups. Dictionaries are ideal for associative data.</p>
                        <pre>
let ages = ["Alice": 25, "Bob": 30]
print(ages["Alice"]!)
                        </pre>
                        <div class="example">
                            <p>Output: 25</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 11 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 11: If Statements</summary>
                    <div class="item-content">
                        <h2>Conditional Statements</h2>
                        <p>Swift’s `if` statements evaluate conditions, supporting `else if` and `else`. They require boolean expressions, ensuring clarity. Conditionals are essential for decision-making in Swift.</p>
                        <pre>
let age = 18
if age >= 18 {
    print("Adult")
} else {
    print("Minor")
}
                        </pre>
                        <div class="example">
                            <p>Output: Adult</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 12 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 12: Switch Statements</summary>
                    <div class="item-content">
                        <h2>Switch Statements</h2>
                        <p>Swift’s `switch` statement matches values against cases, with exhaustive matching and no implicit fall-through. It supports ranges and tuples. Switch statements are powerful for multi-way branching.</p>
                        <pre>
let day = 1
switch day {
case 1:
    print("Monday")
default:
    print("Other")
}
                        </pre>
                        <div class="example">
                            <p>Output: Monday</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 13 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 13: For-In Loops</summary>
                    <div class="item-content">
                        <h2>For-In Loops</h2>
                        <p>Swift’s `for-in` loop iterates over sequences like arrays or ranges. It’s concise and type-safe, avoiding index errors. For-in loops are idiomatic for collection iteration.</p>
                        <pre>
for i in 0..<3 {
    print(i)
}
                        </pre>
                        <div class="example">
                            <p>Output:<br>0<br>1<br>2</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 14 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 14: While Loops</summary>
                    <div class="item-content">
                        <h2>While Loops</h2>
                        <p>Swift’s `while` and `repeat-while` loops execute while a condition is true. `repeat-while` guarantees at least one iteration. While loops are useful for dynamic iteration.</p>
                        <pre>
var i = 0
while i < 3 {
    print(i)
    i += 1
}
                        </pre>
                        <div class="example">
                            <p>Output:<br>0<br>1<br>2</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 15 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 15: Break and Continue</summary>
                    <div class="item-content">
                        <h2>Loop Control</h2>
                        <p>The `break` statement exits a loop, while `continue` skips to the next iteration. Both work in `for` and `while` loops. These controls manage iteration flow in Swift.</p>
                        <pre>
for i in 0..<5 {
    if i == 3 { break }
    print(i)
}
                        </pre>
                        <div class="example">
                            <p>Output:<br>0<br>1<br>2</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 16 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 16: Functions</summary>
                    <div class="item-content">
                        <h2>Defining Functions</h2>
                        <p>Functions in Swift are declared with `func`, supporting parameters, return types, and default values. They can have internal and external parameter names. Functions promote modular, reusable code.</p>
                        <pre>
func greet(name: String) -> String {
    return "Hello, \(name)!"
}
print(greet(name: "Alice"))
                        </pre>
                        <div class="example">
                            <p>Output: Hello, Alice!</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 17 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 17: Optionals</summary>
                    <div class="item-content">
                        <h2>Optionals</h2>
                        <p>Optionals in Swift handle values that may be `nil`, declared with `?`. They’re unwrapped with `if let`, `guard`, or `??`. Optionals ensure safe handling of absent values.</p>
                        <pre>
var optionalName: String? = "Alice"
if let name = optionalName {
    print(name)
}
                        </pre>
                        <div class="example">
                            <p>Output: Alice</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 18 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 18: Optional Chaining</summary>
                    <div class="item-content">
                        <h2>Optional Chaining</h2>
                        <p>Optional chaining in Swift accesses properties or methods on optionals with `?.`, returning `nil` if any part is `nil`. It simplifies safe navigation of complex objects. Optional chaining is widely used in Swift apps.</p>
                        <pre>
struct Person {
    var name: String?
}
let person = Person(name: nil)
print(person.name?.uppercased() ?? "No name")
                        </pre>
                        <div class="example">
                            <p>Output: No name</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 19 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 19: Structs</summary>
                    <div class="item-content">
                        <h2>Structs</h2>
                        <p>Structs in Swift are value types, defined with `struct`, supporting properties and methods. They’re copied on assignment, ensuring safety. Structs are preferred for immutable data models.</p>
                        <pre>
struct Dog {
    var name: String
    func bark() -> String {
        return "\(name) says Woof!"
    }
}
let dog = Dog(name: "Buddy")
print(dog.bark())
                        </pre>
                        <div class="example">
                            <p>Output: Buddy says Woof!</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 20 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 20: Classes</summary>
                    <div class="item-content">
                        <h2>Classes</h2>
                        <p>Classes in Swift are reference types, defined with `class`, supporting inheritance. They use reference semantics, unlike structs. Classes are suitable for shared state and complex objects.</p>
                        <pre>
class Animal {
    var name: String
    init(name: String) {
        self.name = name
    }
}
let animal = Animal(name: "Leo")
print(animal.name)
                        </pre>
                        <div class="example">
                            <p>Output: Leo</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 21 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 21: Inheritance</summary>
                    <div class="item-content">
                        <h2>Inheritance</h2>
                        <p>Swift classes support single inheritance with `:` to inherit properties and methods. The `override` keyword modifies parent behavior. Inheritance organizes related classes hierarchically.</p>
                        <pre>
class Animal {
    func speak() -> String { "Sound" }
}
class Dog: Animal {
    override func speak() -> String {
        return super.speak() + ": Woof!"
    }
}
let dog = Dog()
print(dog.speak())
                        </pre>
                        <div class="example">
                            <p>Output: Sound: Woof!</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 22 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 22: Protocols</summary>
                    <div class="item-content">
                        <h2>Protocols</h2>
                        <p>Protocols in Swift define blueprints of methods or properties, adopted with `:`. They enable polymorphism and are used extensively in Swift APIs. Protocols are central to Swift’s type system.</p>
                        <pre>
protocol Speaker {
    func speak() -> String
}
struct Dog: Speaker {
    func speak() -> String { "Woof!" }
}
let dog = Dog()
print(dog.speak())
                        </pre>
                        <div class="example">
                            <p>Output: Woof!</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 23 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 23: Error Handling</summary>
                    <div class="item-content">
                        <h2>Error Handling</h2>
                        <p>Swift uses `enum` errors with `throw`, caught via `do-catch`. Functions declare `throws` to indicate error potential. Error handling ensures robust Swift programs.</p>
                        <pre>
enum MyError: Error {
    case invalid
}
func risky() throws {
    throw MyError.invalid
}
do {
    try risky()
} catch {
    print("Error: \(error)")
}
                        </pre>
                        <div class="example">
                            <p>Output: Error: invalid</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 24 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 24: Closures</summary>
                    <div class="item-content">
                        <h2>Closures</h2>
                        <p>Closures in Swift are self-contained blocks of code, defined with `{}`. They capture variables and can be passed as arguments. Closures are key for functional programming.</p>
                        <pre>
let greet = { (name: String) in
    return "Hello, \(name)!"
}
print(greet("Alice"))
                        </pre>
                        <div class="example">
                            <p>Output: Hello, Alice!</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 25 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 25: Trailing Closures</summary>
                    <div class="item-content">
                        <h2>Trailing Closures</h2>
                        <p>Trailing closures in Swift allow cleaner syntax for functions taking closures as last arguments. They’re common in APIs like `map` and `filter`. Trailing closures enhance readability.</p>
                        <pre>
let numbers = [1, 2, 3]
let doubled = numbers.map { $0 * 2 }
print(doubled)
                        </pre>
                        <div class="example">
                            <p>Output: [2, 4, 6]</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 26 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 26: Enums</summary>
                    <div class="item-content">
                        <h2>Enums</h2>
                        <p>Enums in Swift define a type with a fixed set of cases, supporting associated values. They can have methods and conform to protocols. Enums are powerful for modeling state.</p>
                        <pre>
enum Direction {
    case north, south, east, west
}
let dir = Direction.north
print(dir)
                        </pre>
                        <div class="example">
                            <p>Output: north</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 27 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 27: Associated Values</summary>
                    <div class="item-content">
                        <h2>Associated Values</h2>
                        <p>Swift enums can store associated values with cases, enabling rich data modeling. They’re accessed via `switch` or pattern matching. Associated values make enums versatile for complex types.</p>
                        <pre>
enum Barcode {
    case upc(Int)
    case qr(String)
}
let code = Barcode.qr("xyz")
print(code)
                        </pre>
                        <div class="example">
                            <p>Output: qr("xyz")</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 28 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 28: Generics</summary>
                    <div class="item-content">
                        <h2>Generics</h2>
                        <p>Generics in Swift allow reusable code with type safety, using `<T>`. They’re used in collections and custom types. Generics enhance flexibility without sacrificing safety.</p>
                        <pre>
func swap<T>(_ a: inout T, _ b: inout T) {
    let temp = a
    a = b
    b = temp
}
var x = 1, y = 2
swap(&x, &y)
print(x, y)
                        </pre>
                        <div class="example">
                            <p>Output: 2 1</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 29 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 29: Properties</summary>
                    <div class="item-content">
                        <h2>Properties</h2>
                        <p>Swift properties include stored (`var`/`let`) and computed properties, with `get`/`set`. They can have observers like `willSet` and `didSet`. Properties manage state in structs and classes.</p>
                        <pre>
struct Circle {
    var radius: Double
    var area: Double {
        return .pi * radius * radius
    }
}
let circle = Circle(radius: 2)
print(circle.area)
                        </pre>
                        <div class="example">
                            <p>Output: 12.566370614359172</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 30 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 30: Access Control</summary>
                    <div class="item-content">
                        <h2>Access Control</h2>
                        <p>Swift’s access control uses keywords like `private`, `internal`, and `public`. It restricts access to properties, methods, and types. Access control ensures encapsulation and modularity.</p>
                        <pre>
class BankAccount {
    private var balance: Double
    init(balance: Double) {
        self.balance = balance
    }
}
let account = BankAccount(balance: 100)
print("Access restricted")
                        </pre>
                        <div class="example">
                            <p>Output: Access restricted</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 31 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 31: File Writing</summary>
                    <div class="item-content">
                        <h2>File Writing</h2>
                        <p>Swift’s `String` can write to files using `write(to:)`, with error handling. Files are accessed via `URL`. File writing is essential for persistent data in Swift.</p>
                        <pre>
import Foundation
let content = "Hello, World!"
try content.write(to: URL(fileURLWithPath: "output.txt"), atomically: true, encoding: .utf8)
print("File written")
                        </pre>
                        <div class="example">
                            <p>Output: File written</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 32 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 32: File Reading</summary>
                    <div class="item-content">
                        <h2>File Reading</h2>
                        <p>Swift reads files using `String(contentsOf:)` or `Data(contentsOf:)`. It throws errors for invalid paths, requiring `try`. File reading retrieves persistent data in Swift.</p>
                        <pre>
import Foundation
let content = try String(contentsOf: URL(fileURLWithPath: "output.txt"))
print(content)
                        </pre>
                        <div class="example">
                            <p>Output: Hello, World!</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 33 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 33: JSON Encoding</summary>
                    <div class="item-content">
                        <h2>JSON Encoding</h2>
                        <p>Swift’s `JSONEncoder` converts `Codable` types to JSON data. It supports custom key strategies and pretty printing. JSON encoding is common for API communication.</p>
                        <pre>
import Foundation
struct User: Codable {
    let name: String
}
let user = User(name: "Alice")
let json = try JSONEncoder().encode(user)
print(String(data: json, encoding: .utf8)!)
                        </pre>
                        <div class="example">
                            <p>Output: {"name":"Alice"}</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 34 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 34: JSON Decoding</summary>
                    <div class="item-content">
                        <h2>JSON Decoding</h2>
                        <p>Swift’s `JSONDecoder` converts JSON to `Codable` types, with error handling. It supports custom date formats and key mappings. JSON decoding is vital for API data processing.</p>
                        <pre>
import Foundation
struct User: Codable {
    let name: String
}
let json = "{\"name\":\"Alice\"}".data(using: .utf8)!
let user = try JSONDecoder().decode(User.self, from: json)
print(user.name)
                        </pre>
                        <div class="example">
                            <p>Output: Alice</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 35 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 35: Regular Expressions</summary>
                    <div class="item-content">
                        <h2>Regular Expressions</h2>
                        <p>Swift uses `NSRegularExpression` for pattern matching, with methods like `matches(in:)`. Patterns are defined with standard regex syntax. Regular expressions are powerful for text processing.</p>
                        <pre>
import Foundation
let text = "hello world"
let regex = try NSRegularExpression(pattern: "world")
let newText = regex.stringByReplacingMatches(in: text, range: NSRange(location: 0, length: text.utf16.count), withTemplate: "Swift")
print(newText)
                        </pre>
                        <div class="example">
                            <p>Output: hello Swift</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 36 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 36: Higher-Order Functions</summary>
                    <div class="item-content">
                        <h2>Higher-Order Functions</h2>
                        <p>Swift’s higher-order functions like `map`, `filter`, and `reduce` process collections functionally. They take closures for custom logic. These functions promote concise, expressive code.</p>
                        <pre>
let numbers = [1, 2, 3]
let squares = numbers.map { $0 * $0 }
print(squares)
                        </pre>
                        <div class="example">
                            <p>Output: [1, 4, 9]</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 37 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 37: Extensions</summary>
                    <div class="item-content">
                        <h2>Extensions</h2>
                        <p>Extensions in Swift add functionality to existing types, using `extension`. They can add methods, properties, or protocol conformance. Extensions enhance code modularity and reuse.</p>
                        <pre>
extension String {
    func shout() -> String {
        return self.uppercased() + "!"
    }
}
print("hello".shout())
                        </pre>
                        <div class="example">
                            <p>Output: HELLO!</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 38 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 38: Async/Await</summary>
                    <div class="item-content">
                        <h2>Async/Await</h2>
                        <p>Swift’s `async`/`await` syntax handles asynchronous code, declared with `async` and called with `await`. It simplifies concurrency over callbacks. Async/await is modern Swift’s concurrency model.</p>
                        <pre>
import Foundation
func fetch() async -> String {
    return "Data"
}
Task {
    let result = await fetch()
    print(result)
}
                        </pre>
                        <div class="example">
                            <p>Output: Data</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 39 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 39: Actors</summary>
                    <div class="item-content">
                        <h2>Actors</h2>
                        <p>Actors in Swift ensure thread-safe concurrency, declared with `actor`. They isolate state, accessed via `await`. Actors are key for safe concurrent programming.</p>
                        <pre>
actor Counter {
    var value = 0
    func increment() {
        value += 1
    }
}
Task {
    let counter = Counter()
    await counter.increment()
    print(await counter.value)
}
                        </pre>
                        <div class="example">
                            <p>Output: 1</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 40 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 40: Property Wrappers</summary>
                    <div class="item-content">
                        <h2>Property Wrappers</h2>
                        <p>Property wrappers in Swift encapsulate property behavior, defined with `@`. They simplify code for patterns like lazy loading. Property wrappers are powerful for reusable logic.</p>
                        <pre>
@propertyWrapper
struct Clamped {
    private var value: Int
    init(wrappedValue: Int) {
        self.value = max(0, min(wrappedValue, 10))
    }
    var wrappedValue: Int {
        get { value }
        set { value = max(0, min(newValue, 10)) }
    }
}
struct Settings {
    @Clamped var level: Int
}
var settings = Settings(level: 15)
print(settings.level)
                        </pre>
                        <div class="example">
                            <p>Output: 10</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 41 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 41: Networking</summary>
                    <div class="item-content">
                        <h2>Networking</h2>
                        <p>Swift’s `URLSession` performs network requests, with `async` support for modern APIs. It handles JSON and errors safely. Networking is crucial for iOS apps.</p>
                        <pre>
import Foundation
struct Todo: Codable {
    let title: String
}
let url = URL(string: "https://jsonplaceholder.typicode.com/todos/1")!
let (data, _) = try await URLSession.shared.data(from: url)
let todo = try JSONDecoder().decode(Todo.self, from: data)
print(todo.title)
                        </pre>
                        <div class="example">
                            <p>Output: (Sample todo title, e.g., "delectus aut autem")</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 42 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 42: SwiftUI Introduction</summary>
                    <div class="item-content">
                        <h2>SwiftUI Introduction</h2>
                        <p>SwiftUI is Apple’s declarative UI framework for building iOS/macOS apps. It uses structs and `@State` for reactive views. SwiftUI simplifies UI development with live previews.</p>
                        <pre>
import SwiftUI
struct ContentView: View {
    var body: some View {
        Text("Hello, World!")
    }
}
                        </pre>
                        <div class="example">
                            <p>Output: (Renders "Hello, World!" in SwiftUI preview)</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 43 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 43: SwiftUI State</summary>
                    <div class="item-content">
                        <h2>SwiftUI State</h2>
                        <p>SwiftUI’s `@State` property wrapper manages view state, triggering UI updates. It’s private to the view for safety. State is fundamental to interactive SwiftUI apps.</p>
                        <pre>
import SwiftUI
struct CounterView: View {
    @State private var count = 0
    var body: some View {
        VStack {
            Text("Count: \(count)")
            Button("Increment") { count += 1 }
        }
    }
}
                        </pre>
                        <div class="example">
                            <p>Output: (Displays counter with increment button)</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 44 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 44: SwiftUI Lists</summary>
                    <div class="item-content">
                        <h2>SwiftUI Lists</h2>
                        <p>SwiftUI’s `List` displays scrollable rows, using `ForEach` for dynamic data. It supports selection and navigation. Lists are common in iOS apps for data display.</p>
                        <pre>
import SwiftUI
struct ListView: View {
    let items = ["Apple", "Banana", "Cherry"]
    var body: some View {
        List(items, id: \.self) { item in
            Text(item)
        }
    }
}
                        </pre>
                        <div class="example">
                            <p>Output: (Displays scrollable list of fruits)</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 45 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 45: SwiftUI Navigation</summary>
                    <div class="item-content">
                        <h2>SwiftUI Navigation</h2>
                        <p>SwiftUI’s `NavigationStack` and `NavigationLink` enable view navigation. They manage a navigation stack for hierarchical UIs. Navigation is key for multi-screen iOS apps.</p>
                        <pre>
import SwiftUI
struct MainView: View {
    var body: some View {
        NavigationStack {
            NavigationLink("Go to Detail", destination: Text("Detail View"))
                .navigationTitle("Home")
        }
    }
}
                        </pre>
                        <div class="example">
                            <p>Output: (Navigates from link to detail view)</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 46 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 46: Core Data</summary>
                    <div class="item-content">
                        <h2>Core Data</h2>
                        <p>Core Data is Apple’s framework for persistent data, integrated with Swift. It uses a managed object context for data operations. Core Data is ideal for local storage in iOS apps.</p>
                        <pre>
import CoreData
let container = NSPersistentContainer(name: "Model")
container.loadPersistentStores { _, _ in }
print("Core Data initialized")
                        </pre>
                        <div class="example">
                            <p>Output: Core Data initialized</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 47 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 47: Core Data Entities</summary>
                    <div class="item-content">
                        <h2>Core Data Entities</h2>
                        <p>Core Data entities are defined in a model file, mapped to Swift classes. They support CRUD operations via `NSManagedObject`. Entities manage structured data in Swift apps.</p>
                        <pre>
import CoreData
let container = NSPersistentContainer(name: "Model")
container.loadPersistentStores { _, _ in }
let context = container.viewContext
let user = NSEntityDescription.insertNewObject(forEntityName: "User", into: context)
user.setValue("Alice", forKey: "name")
try context.save()
print("User saved")
                        </pre>
                        <div class="example">
                            <p>Output: User saved</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 48 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 48: Combine</summary>
                    <div class="item-content">
                        <h2>Combine</h2>
                        <p>Combine is Swift’s reactive framework for handling asynchronous events. It uses publishers and subscribers for data streams. Combine is powerful for reactive iOS apps.</p>
                        <pre>
import Combine
let publisher = Just("Hello")
    .sink { value in
        print(value)
    }
                        </pre>
                        <div class="example">
                            <p>Output: Hello</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 49 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 49: Unit Testing</summary>
                    <div class="item-content">
                        <h2>Unit Testing</h2>
                        <p>Swift uses XCTest for unit testing, with test cases in `XCTestCase`. Tests use assertions like `XCTAssertEqual`. Unit testing ensures reliable Swift code.</p>
                        <pre>
import XCTest
class MathTests: XCTestCase {
    func testAdd() {
        XCTAssertEqual(2 + 2, 4)
    }
}
                        </pre>
                        <div class="example">
                            <p>Output: (Test passes, no console output)</p>
                        </div>
                    </div>
                </details>
            </div>

            <!-- Lesson 50 -->
            <div class="item">
                <details>
                    <summary class="item-button">Lesson 50: App Lifecycle</summary>
                    <div class="item-content">
                        <h2>App Lifecycle</h2>
                        <p>SwiftUI apps manage lifecycle with `@main` and `App` protocol. Scenes like `WindowGroup` define UI entry points. Understanding the lifecycle is key for iOS development.</p>
                        <pre>
import SwiftUI
@main
struct MyApp: App {
    var body: some Scene {
        WindowGroup {
            ContentView()
        }
    }
}
struct ContentView: View {
    var body: some View {
        Text("Welcome")
    }
}
                        </pre>
                        <div class="example">
                            <p>Output: (Launches app with "Welcome" view)</p>
                        </div>
                    </div>
                </details>
            </div>
        </section>
    </main>

    <footer>
        <p>© 2025 CODEXEDOC. All rights reserved.</p>
    </footer>

    <script>
        // Hamburger menu toggle
        const hamburger = document.querySelector('.hamburger');
        const navMenu = document.querySelector('.nav-menu');

        hamburger.addEventListener('click', () => {
            hamburger.classList.toggle('active');
            navMenu.classList.toggle('active');
        });

        // Close dropdown when clicking a link
        document.querySelectorAll('.nav-menu a').forEach(link => {
            link.addEventListener('click', () => {
                hamburger.classList.remove('active');
                navMenu.classList.remove('active');
            });
        });
    </script>
</body>
</html>
